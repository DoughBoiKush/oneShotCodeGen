{
"files":{
"backend/.env":"PORT=3000\nDB_PATH=./database.sqlite\nJWT_SECRET=your-secret-key-here\nNODE_ENV=development",
"backend/config/database.js":"const { Sequelize } = require('sequelize');\nconst path = require('path');\nconst dbPath = path.resolve(process.env.DB_PATH);\nconst sequelize = new Sequelize({dialect: 'sqlite',storage: dbPath,logging: false});\nmodule.exports = sequelize;",
"backend/models/User.js":"const { DataTypes } = require('sequelize');\nconst sequelize = require('../config/database');\nconst User = sequelize.define('User', {id: {type: DataTypes.INTEGER,primaryKey: true,autoIncrement: true},email: {type: DataTypes.STRING,unique: true,allowNull: false},password: {type: DataTypes.STRING,allowNull: false},role: {type: DataTypes.ENUM('user', 'admin'),defaultValue: 'user'}});\nmodule.exports = User;",
"backend/models/Prompt.js":"const { DataTypes } = require('sequelize');\nconst sequelize = require('../config/database');\nconst Prompt = sequelize.define('Prompt', {id: {type: DataTypes.INTEGER,primaryKey: true,autoIncrement: true},content: {type: DataTypes.TEXT,allowNull: false},title: {type: DataTypes.STRING,allowNull: false},averageRating: {type: DataTypes.FLOAT,defaultValue: 0}});\nmodule.exports = Prompt;",
"backend/models/Chain.js":"const { DataTypes } = require('sequelize');\nconst sequelize = require('../config/database');\nconst Chain = sequelize.define('Chain', {id: {type: DataTypes.INTEGER,primaryKey: true,autoIncrement: true},name: {type: DataTypes.STRING,allowNull: false},description: {type: DataTypes.TEXT}});\nmodule.exports = Chain;",
"backend/models/Rating.js":"const { DataTypes } = require('sequelize');\nconst sequelize = require('../config/database');\nconst Rating = sequelize.define('Rating', {id: {type: DataTypes.INTEGER,primaryKey: true,autoIncrement: true},score: {type: DataTypes.INTEGER,allowNull: false},parameter: {type: DataTypes.STRING,allowNull: false}});\nmodule.exports = Rating;",
"backend/models/index.js":"const sequelize = require('../config/database');\nconst User = require('./User');\nconst Prompt = require('./Prompt');\nconst Chain = require('./Chain');\nconst Rating = require('./Rating');\nUser.hasMany(Prompt);\nPrompt.belongsTo(User);\nUser.hasMany(Rating);\nRating.belongsTo(User);\nPrompt.hasMany(Rating);\nRating.belongsTo(Prompt);\nChain.belongsToMany(Prompt, {through: 'ChainPrompts'});\nPrompt.belongsToMany(Chain, {through: 'ChainPrompts'});\nUser.hasMany(Chain);\nChain.belongsTo(User);\nmodule.exports = {sequelize,User,Prompt,Chain,Rating};",
"backend/controllers/auth.js":"const jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\nconst { User } = require('../models');\nconst login = async (req, res) => {try {const { email, password } = req.body;const user = await User.findOne({ where: { email }});if (!user || !bcrypt.compareSync(password, user.password)) return res.status(401).json({ message: 'Invalid credentials' });const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET);res.json({ token });} catch (error) {res.status(500).json({ message: error.message })}};\nconst register = async (req, res) => {try {const { email, password } = req.body;const hashedPassword = bcrypt.hashSync(password, 10);const user = await User.create({ email, password: hashedPassword });const token = jwt.sign({ id: user.id, role: user.role }, process.env.JWT_SECRET);res.status(201).json({ token });} catch (error) {res.status(400).json({ message: error.message })}};\nmodule.exports = { login, register };",
"backend/controllers/prompts.js":"const { Prompt, Rating, User, Chain } = require('../models');\nconst create = async (req, res) => {try {const prompt = await Prompt.create({ ...req.body, UserId: req.user.id });res.status(201).json(prompt);} catch (error) {res.status(400).json({ message: error.message })}};\nconst getAll = async (req, res) => {try {const prompts = await Prompt.findAll({include: [{model: Rating},{model: User,attributes: ['email']},{model: Chain}]});res.json(prompts);} catch (error) {res.status(500).json({ message: error.message })}};\nconst update = async (req, res) => {try {const prompt = await Prompt.findByPk(req.params.id);if (!prompt) return res.status(404).json({ message: 'Prompt not found' });if (prompt.UserId !== req.user.id && req.user.role !== 'admin') return res.status(403).json({ message: 'Unauthorized' });await prompt.update(req.body);res.json(prompt);} catch (error) {res.status(400).json({ message: error.message })}};\nconst remove = async (req, res) => {try {const prompt = await Prompt.findByPk(req.params.id);if (!prompt) return res.status(404).json({ message: 'Prompt not found' });if (prompt.UserId !== req.user.id && req.user.role !== 'admin') return res.status(403).json({ message: 'Unauthorized' });await prompt.destroy();res.status(204).send();} catch (error) {res.status(500).json({ message: error.message })}};\nmodule.exports = { create, getAll, update, remove };",
"backend/controllers/chains.js":"const { Chain, Prompt } = require('../models');\nconst create = async (req, res) => {try {const chain = await Chain.create({ ...req.body, UserId: req.user.id });res.status(201).json(chain);} catch (error) {res.status(400).json({ message: error.message })}};\nconst getAll = async (req, res) => {try {const chains = await Chain.findAll({include: [Prompt]});res.json(chains);} catch (error) {res.status(500).json({ message: error.message })}};\nconst update = async (req, res) => {try {const chain = await Chain.findByPk(req.params.id);if (!chain) return res.status(404).json({ message: 'Chain not found' });if (chain.UserId !== req.user.id && req.user.role !== 'admin') return res.status(403).json({ message: 'Unauthorized' });await chain.update(req.body);res.json(chain);} catch (error) {res.status(400).json({ message: error.message })}};\nconst remove = async (req, res) => {try {const chain = await Chain.findByPk(req.params.id);if (!chain) return res.status(404).json({ message: 'Chain not found' });if (chain.UserId !== req.user.id && req.user.role !== 'admin') return res.status(403).json({ message: 'Unauthorized' });await chain.destroy();res.status(204).send();} catch (error) {res.status(500).json({ message: error.message })}};\nmodule.exports = { create, getAll, update, remove };",
"backend/middleware/auth.js":"const jwt = require('jsonwebtoken');\nconst authenticate = (req, res, next) => {try {const token = req.headers.authorization?.split(' ')[1];if (!token) return res.status(401).json({ message: 'Authentication required' });const decoded = jwt.verify(token, process.env.JWT_SECRET);req.user = decoded;next();} catch (error) {res.status(401).json({ message: 'Invalid token' })}};\nconst isAdmin = (req, res, next) => {if (req.user.role !== 'admin') return res.status(403).json({ message: 'Admin access required' });next();};\nmodule.exports = { authenticate, isAdmin };",
"backend/routes/auth.js":"const express = require('express');\nconst router = express.Router();\nconst { login, register } = require('../controllers/auth');\nrouter.post('/login', login);\nrouter.post('/register', register);\nmodule.exports = router;",
"backend/routes/prompts.js":"const express = require('express');\nconst router = express.Router();\nconst { authenticate } = require('../middleware/auth');\nconst { create, getAll, update, remove } = require('../controllers/prompts');\nrouter.use(authenticate);\nrouter.post('/', create);\nrouter.get('/', getAll);\nrouter.put('/:id', update);\nrouter.delete('/:id', remove);\nmodule.exports = router;",
"backend/routes/chains.js":"const express = require('express');\nconst router = express.Router();\nconst { authenticate } = require('../middleware/auth');\nconst { create, getAll, update, remove } = require('../controllers/chains');\nrouter.use(authenticate);\nrouter.post('/', create);\nrouter.get('/', getAll);\nrouter.put('/:id', update);\nrouter.delete('/:id', remove);\nmodule.exports = router;",
"backend/seeders/index.js":"const bcrypt = require('bcryptjs');\nconst { User, Prompt, Chain, Rating } = require('../models');\nconst seed = async () => {try {const adminUser = await User.create({email: 'user@example.com',password: bcrypt.hashSync('test123', 10),role: 'admin'});const prompt = await Prompt.create({title: 'Test Prompt',content: 'This is a test prompt',UserId: adminUser.id});const chain = await Chain.create({name: 'Test Chain',description: 'Test chain description',UserId: adminUser.id});await Rating.create({score: 5,parameter: 'quality',UserId: adminUser.id,PromptId: prompt.id});await chain.addPrompt(prompt);} catch (error) {console.error('Seeding error:', error);}};\nmodule.exports = seed;",
"backend/server.js":"require('dotenv').config();\nconst express = require('express');\nconst cors = require('cors');\nconst { sequelize } = require('./models');\nconst seed = require('./seeders');\nconst app = express();\napp.use(cors());\napp.use(express.json());\napp.use('/api/auth', require('./routes/auth'));\napp.use('/api/prompts', require('./routes/prompts'));\napp.use('/api/chains', require('./routes/chains'));\nsequelize.sync().then(async () => {const tables = await sequelize.showAllSchemas();if (tables.length === 0) {await seed();}app.listen(process.env.PORT, () => console.log(`Server running on port ${process.env.PORT}`));});"
},
"commands":["mkdir backend","cd backend && npm init -y","cd backend && npm install express sequelize sqlite3 bcryptjs jsonwebtoken cors dotenv"]
}